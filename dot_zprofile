# .zprofile --- Processed by login shells, before .zshenv
# Mike Barker <mike@thebarkers.com>
# Created: November 3rd, 2022
# Updated: November 5th, 2025

## Description:
# This file should contain commands to set the command search path, plus other
# important environment variables. `.zshenv' should not contain commands that
# produce output or assume the shell is attached to a tty.
#
# Startup files processed order
# /etc/zshenv
# $ZDOTDIR/.zshenv
# If the shell is a login shell:
#     /etc/zprofile
#     $ZDOTDIR/.zprofile
# If the shell is interactive:
#     /etc/zshrc
#     $ZDOTDIR/.zshrc
# If the shell is a login shell:
#     /etc/zlogin
#     $ZDOTDIR/.zlogin
# When a login shell exits:
#     $ZDOTDIR/.zlogout
#     /etc/zlogout
#
# Startup behaviour can be modified by the RCS and GLOBAL_RCS options. If
# ZDOTDIR is unset, HOME is used instead. See the docs for more info:
# https://zsh.sourceforge.io/Doc/Release/Files.html#Startup_002fShutdown-Files

## Notes:
# On macOS the file /etc/zprofile calls the path_helper command and will clobber
# the order of the PATH being setup in the .zshenv file.
# For more info see this gist: 
# https://gist.github.com/Linerre/f11ad4a6a934dcf01ee8415c9457e7b2#solutions
# 
# My solution is to set the environment here instead of in the .zshenv file.
# This file is processed after /etc/zprofile and will set the environment and
# path correctly. This also this means that the environment will only be
# configured by login shells and not every subshell.

## Debug trace function
# To help with debuging set the DEBUG variable to 1
# $ DEBUG=1 zsh -l
debug_trace() {
    [[ -n "$DEBUG" ]] && echo $1
}

# Print the sourced file's name
debug_trace "Loading: ${(%):-%1N}..."

## Configure the homebrew environment
if [[ -x /opt/homebrew/bin/brew ]]; then
    BREW="/opt/homebrew/bin/brew"
elif [[ -x /usr/local/bin/brew ]]; then
    BREW="/usr/local/bin/brew"
elif [[ -x /home/linuxbrew/.linuxbrew/bin/brew ]]; then
    BREW="/home/linuxbrew/.linuxbrew/bin/brew"
elif [[ -x "$HOME/.linuxbrew/bin/brew" ]]; then
    BREW="$HOME/.linuxbrew/bin/brew"
else
    BREW=""
fi
if [[ "$BREW" != "" ]]; then
    debug_trace "Setup homebrew..."
    eval "$($BREW shellenv)"
fi
unset BREW

## Configure pyenv environment
if [[ -d ${HOME}/.pyenv ]]; then
    debug_trace "Setup pyenv..."
    export PYENV_ROOT="$HOME/.pyenv"
    export PATH="$PYENV_ROOT/bin:$PATH"
    eval "$(pyenv init --path)"
fi

## Configure rbenv environment
if [[ $(command -v rbenv) ]]; then
    debug_trace "Setup rbenv..."
    eval "$(rbenv init -)"
fi

## Fixup vscode-server path
# If there is a vscode-server path element, it must be before any path that has
# the locally installed code server. This code will find the first path element
# that has vscode-server, remove it from the path array and prepend it to the
# start.

# Find the index of any element in the $path array that contains .vscode-server
# If found (i.e. the index is valid), move the .vscode-server path to the front
vscode_index=${path[(i)*.vscode-server*]}
if [[ $vscode_index -le ${#path} ]]; then
    debug_trace "Fixup vscode server path..."
    vscode_path=${path[vscode_index]}
    path[$vscode_index]=()
    path=($vscode_path $path)
fi


## Configure the path
# Any path that does not exist on the current system will not be added to the
# system path.

# Create an newpath array
newpath=(
    # Prepend paths
    "$HOME/bin"
    "$HOME/.local/bin"
    # mise - https://mise.jdx.dev
    "$HOME/.local/share/mise/shims"
    # Add the existing paths to the newpath array
    $path
    # Append paths
    /usr/local/sbin
)

# Remove duplicate entries from the new path
typeset -U newpath

# Replace the system path using the newpath array,
# only existing paths will be added to the new path.
path=($^newpath(N))
unset newpath

